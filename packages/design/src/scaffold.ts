import { parser } from './diagram/parser'
import { camelCase } from 'lodash'
import * as path from 'path'
import { statementsToGraph, ChoiceNode, StateNode, EndStateName, StartStateName } from './parse-nodes'

const pascalCase = (identifier: string) => camelCase(identifier).replace(/^(\w)/, s => s.toUpperCase())

parser.yy = {
    setDirection: () => {
        // Intentionally left empty
    },
    trimColon: (text: string) => {
        return (/^\s*:\s*(.+)/.exec(text) ?? ['', ''])[1].trim()
    },
    setRootDoc: () => {
        // Intentionally left empty
    },
    getDividerId: () => {
        // Currently unused
        throw new Error('Unexpected usage of getDividerId')
    },
    setAccDescription: () => {
        // Currently unused
        throw new Error('Unexpected usage of setAccDescription')
    },
    setAccTitle: () => {
        // Currently unused
        throw new Error('Unexpected usage of setAccTitle')
    },
}

function splitFile(mermaidContents: string): { header: string; diagramBody: string } {
    const split = /---(.+)---(.+)/s.exec(mermaidContents)

    if (split === null) {
        throw new Error('Unable to parse Mermaid diagram - please check that you have both a header and a diagram.')
    }

    return {
        header: split[1].trim(),
        diagramBody: split[2].trim(),
    }
}

function titleNameFromHeader(header: string): string {
    const titleExec = /^title\s*:\s*(.+)$/m.exec(header)

    if (titleExec === null) {
        throw new Error('Mermaid diagram must have a title. Please specify one in the header.')
    }

    return pascalCase(titleExec[1])
}

function fillScaffoldTemplate(
    implementationRef: string,
    decisionVariables: string[],
    registerStepCalls: string[],
    functionDeclarationsCode: string[],
    firstTaskName: string,
    firstPayloadName: string,
    payloadNames: string[],
    workflowName: string,
): string {
    return `/* This file is automatically generated. It gets overwritten on build */
import {CompleteWorkflow, WrongTimingError, WorkflowBase} from "@gamgee/run";
import {StateStore} from "@gamgee/interfaces/store";
import {WorkflowTask} from "@gamgee/interfaces/task";

import {${payloadNames.join(', ')}} from "${implementationRef}";

export abstract class ${workflowName}Base extends WorkflowBase {
    protected constructor() {
        super('${workflowName}');
        
        ${registerStepCalls.join('\n        ')}
    }
    
    async submit(payload: ${firstPayloadName}, store: StateStore, uniqueInstanceId?: string): Promise<string> {
        const task = await super._enqueue('${escapeString(firstTaskName)}', payload, store, uniqueInstanceId);
        return task.instanceId;
    }

    ${functionDeclarationsCode.join('\n\n    ')}
    
    ${decisionVariables.join('\n')}

    protected _registerStep() {
        throw new WrongTimingError();
    }
    
    protected _enqueue(): Promise<WorkflowTask> {
        throw new WrongTimingError();
    }
}`
}

function stepNameToPayloadName(stepName: string) {
    return `${pascalCase(stepName)}Payload`
}

function escapeString(str: string) {
    return str.replace("'", "\\'")
}

function variableFromDecision(node: ChoiceNode) {
    const outcomes = Object.entries(node.goesTo).map(([optionName, toNode]) => {
        if (toNode.name !== EndStateName) {
            return `
        ${camelCase(optionName)}(payload: ${stepNameToPayloadName(toNode.name)}) {
            return {
                targetTaskName: '${escapeString(toNode.name)}',
                payload,
            }
        },`
        } else {
            return `
        ${camelCase(optionName)}() {
            return CompleteWorkflow;
        },`
        }
    })

    return `protected ${camelCase(node.name)} = {${outcomes.join('')}
    }`
}

function registerStepCallCodeFromStep(node: StateNode) {
    return `super._registerStep({ name: '${escapeString(node.name)}', run: this.${nodeToInvokeFunctionName(node)}, attempts: ${node.knownAttributes.attempts || 1}, backoffMs: ${node.knownAttributes.backoffMs || 1000} });`
}

function stepNameToFunctionName(name: string) {
    return camelCase(name)
}

function nodeToInvokeFunctionName(node: StateNode) {
    if (node.goesTo[0].type === 'Choice') {
        return stepNameToFunctionName(node.name)
    }

    return `invoke${pascalCase(stepNameToFunctionName(node.name))}`
}

function functionDeclarationCodeFromStep(node: StateNode) {
    let returnType: string
    let invokeFunction: string | undefined

    const nextStep = node.goesTo[0]

    if (nextStep.name === EndStateName) {
        returnType = 'Promise<void>'
        invokeFunction = `
    private async ${nodeToInvokeFunctionName(node)}(payload: ${stepNameToPayloadName(node.name)}): Promise<CompleteWorkflow> {
        await this.${stepNameToFunctionName(node.name)}(payload);
        return Promise.resolve(CompleteWorkflow);
    }
`
    } else if (nextStep.type === 'State') {
        returnType = `Promise<${stepNameToPayloadName(nextStep.name)}>`
        invokeFunction = `
    private async ${nodeToInvokeFunctionName(node)}(payload: ${stepNameToPayloadName(node.name)}): Promise<{ targetTaskName: '${nextStep.name}'; payload: ${stepNameToPayloadName(nextStep.name)} }> {
        const response: ${stepNameToPayloadName(nextStep.name)} = await this.${stepNameToFunctionName(node.name)}(payload);
        return { targetTaskName: '${nextStep.name}', payload: response };
    }
`
    } else {
        returnType = Object.keys(nextStep.goesTo)
            .map(
                optionName =>
                    `Promise<ReturnType<(typeof this.${camelCase(nextStep.name)})['${camelCase(optionName)}']>>`,
            )
            .join(' | ')
    }

    const abstractFunctionSignature = `abstract ${stepNameToFunctionName(node.name)}(payload: ${stepNameToPayloadName(node.name)}): ${returnType};`

    return [invokeFunction, abstractFunctionSignature].filter(s => !!s).join('\n    ')
}

function compressNewlines(content: string) {
    let prev = content
    let next = content.replaceAll('\n\n\n', '\n\n')

    while (next.length < prev.length) {
        prev = next
        next = next.replaceAll('\n\n\n', '\n\n')
    }

    return next
}

// TODO: implementationRelativePath is currently useless
export function mermaidToScaffold(
    mermaidContents: string,
    diagramFilePath: string,
    implementationRelativePath: string,
) {
    const { header, diagramBody } = splitFile(mermaidContents)

    const titleName = titleNameFromHeader(header)

    const output = parser.parse(diagramBody)

    const { states, choices } = statementsToGraph(output)
    const firstStep = states[StartStateName].goesTo[0]
    const statesExcludingFirst = states
    delete statesExcludingFirst[StartStateName]

    const decisionVariables: string[] = Object.values(choices).map(d => variableFromDecision(d))
    const registerStepCalls: string[] = Object.values(statesExcludingFirst).map(s => registerStepCallCodeFromStep(s))
    const functionDeclarationsCode: string[] = Object.values(statesExcludingFirst).map(s =>
        functionDeclarationCodeFromStep(s),
    )

    const baseName = path.basename(diagramFilePath, path.extname(diagramFilePath))
    const generatedFilePath = path.join(path.dirname(diagramFilePath), baseName + '.generated.ts')
    const implementationRef = `${implementationRelativePath}/${baseName}`.replace('//', '/')

    const contents = fillScaffoldTemplate(
        implementationRef,
        decisionVariables,
        registerStepCalls,
        functionDeclarationsCode,
        firstStep.name,
        stepNameToPayloadName(firstStep.name),
        Object.keys(statesExcludingFirst).map(name => stepNameToPayloadName(name)),
        pascalCase(titleName).replace(/(Workflow)?$/i, 'Workflow'),
    )

    return {
        generatedFilePath,
        contents: compressNewlines(
            // Drop trailing spaces
            contents.replaceAll(/ +\n^/gm, '\n'),
        ),
    }
}
